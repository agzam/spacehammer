#+title: Advising API

* What is it?

Inspired by emacs, the advising system allows SpaceHammer developers
to define functions that users can hook to run operations before,
after, wrap, or replace the original implementation. This gives users
the flexibility to customize behavior without having to create
extraneous config.fnl options.

* Defining an Advisable Function

Unlike emacs, functions are not advisable by default, in fennel, the
=defn= and =afn= macros can define advisable functions.

** defn

The defn macro works like =fn= except that it only works for
module-level locals, it will not work for ad-hoc functions created
within a =let= form.

Usage:

#+begin_src fennel
(defn function-name
      [args]
      "docstr"
      body-1
      ...body ;; Optional
      )
#+end_src

- ="docstr"= is always required for advisable functions, it's a best
  practice for root module functions and will help guide people who
  wish to advise it.

- At least one body form is required. If stubbing out a function =nil=
  will do just fine. This is a requirement that comes from the fennel
  =(fn)= special form.


Example:

#+begin_src fennel
(import-macros {: defn
                : defadvice} :lib.advice.macros)

(defn defn-func-1
      [x y z]
      "docstr"
      "Hi")

(defn-func-1)
;; => "Hi"

(defadvice defn-func-override
           [x y z]
           :override defn-func-1
           "Overrides defn-func-1"
           "over-it")

(defn-func-1)
;; => "over-it"
#+end_src

The =defn= macro transforms the above call into the following:

#+begin_src fennel
(local defn-func-1
       (let [adv_0_ (require "lib.advice")]
         (adv_0_.make-advisable
          "defn-func-2" (fn [x y z]
                          "docstr"
                          "hi"))))
#+end_src

The =defn= macro should be the primary API for creating advisable
functions, but =afn= covers the use cases where =defn= will not work.

** afn

The afn macro supports inline functions defined as callback arguments
to higher-order-functions or when creating bespoke functions in =let= forms.

Usage:

#+begin_src fennel
(afn function-name
     [args]
     body-1
     ...body ;; Optional
     )
#+end_src

- It's nearly identical to =defn= but the docstr is not supported.
- At least one function body form is required. Can be =nil= if trying to
  make a noop or placeholder function.

Example:

#+begin_src fennel
(import-macros {: afn
                : defadvice} :lib.advice.macros)

(let [scoped-func (afn scoped-func
                       [x y z]
                       "default")]
  (scoped-func)
  ;; => "default"

  (defadvice scoped-func-advice
    [x y z]
    :override scoped-func
    "Overrides scoped-func"
    "over-it")

  (scoped-func)
  ;; => "over-it"

  )
#+end_src

The =afn= macro transforms the above call into:

#+begin_src fennel
(let [adv_0_ (require "lib.advice")]
  (adv_0_.make-advisable
   "priv-func"
   (fn [x y z]
     "default")))
#+end_src

** make-advisable

Lastly if macros are not an option for whatever reason, they mostly
wrap the =make-advisable= function.

Usage:

#+begin_src fennel
(make-advisable "unique key"
  (fn [args]
    body-1
    ...body ;; Optional
  ))
#+end_src


* Adding Advice

With an advisable function created, we can now add advice to extend
the behaviors. This section will cover the APIs to add advice, and the
next section will cover the supported advice types.

** Function references or strings

The add advice APIs accept both a target function or the unique key
pointing to an advisable function entry. Only functions defined with
=defn=, =afn=, or =make-advisable= are supported.

For example, if this fennel code was in the []:

#+begin_src fennel
(import-macros {: defn} :lib.advice.macros)

(defn defn-func-2
      [x y z]
      "docstr"
      "default")

(print defn-func-2.key)
#+end_src

It would print the following:

#+begin_src fennel
"test/advice-test/defn-func-2"
#+end_src

That key is a unique pointer to an advisable function. It can be
passed as the target to both the =defadvice= macro and =add-advice=
function. It is always calculated from the =~/.hammerspoon= root, if you
are creating advisable functions within your =~/.spacehammer= directory,
the keys will start with ="spacehammer"=.

The following forms are equivalent:

#+begin_src fennel
(add-advice defn-func-2 :override (fn [x y z] "over-it"))
(add-advice :test/advice-test/defn-func-2 :override (fn [x y z] "over-it"))
#+end_src

** Order does not matter

Advice can be defined before the advisable function exists:

#+begin_src fennel
(import-macros {: defn
                : defadvice} :lib.advice.macros)

(defadvice defn-func-override
           [x y z]
           :override defn-func-3
           "Overrides defn-func-3"
           "over-it")

(defn defn-func-3
      [x y z]
      "docstr"
      "Hi")

(defn-func-3)
;; => "over-it"
#+end_src

** Advising APIs

*** defadvice

The =defadvice= macro should be the primary means for adding advice but
a direct =add-advice= alternative is available.

Usage:

#+begin_src fennel
(defadvice advisor-function-name
  [x y z]
  :override target-function-or-key
  "docstr"
  body-1
  ...body ;; Optional
  )
#+end_src

- The string keyword =:override= refers to one of many advice types
  described below.
- The advisor-function-name makes it easier to track advice later
- A docstr is required
- At least one body form is required, =nil= may be used for noop and
  placeholder functions

Example:

#+begin_src fennel
(defn defn-func-4
      [x y z]
      "docstr"
      "default")

(defadvice defn-func-override
           [x y z]
           :override defn-func-4
           "Overrides defn-func-4"
           "over-it")

(defn-func-4)
;; => "over-it"
#+end_src

- defn-func-override completely overrides defn-func-4
- When defn-func-4 is called, defn-func-override is called instead
  returning "over-it" instead of "default"

The defadvice call above expands to:

#+begin_src fennel
(let [adv_0_ (require "lib.advice")]
  (adv_0_.add-advice
   defn-func-override
   "override"
   (fn defn-func-4 [x y z]
     "Overrides defn-func-4"
     "over-it")))
#+end_src

*** add-advice

If in the event =defadvice= macro does not work, the =add-advice= function
may be better suited. It's what =defadvice= uses under the hood.

Usage:

#+begin_src fennel
(add-advice target-function-or-key :advice-type advice-function)
#+end_src

- target-function-or-key refers to advisable-fn.key or the string itself
- :advice-type refers to one of many advice types described below
- advice-function depends on the advice type as it will receive
  different args along with different expected return types

Example:

#+begin_src fennel
(defn defn-func-5
      [x y z]
      "docstr"
      "default")

(add-advice defn-func-5
            :override (fn [x y z]
                        "over-it"))

(defn-func-5)
;; => "over-it"
#+end_src

- Identical behavior to the =defadvice= behavior described above, but a
  more primitive API.
- It's recommended to use =defadvice= most of the time as it enforces
  better habits that will keep projects from becoming a mess.

* Advise Types

This doc exclusively showcases the =override= advice-type but there are
many more to choose from. Each will receive a different set of args,
expect a different return type, and may fire at different times during
the execution cycle.

** override

Replaces the target function and receives the arguments the original
function was called with. May return any value but be mindful of what
callers are expecting.

Behavior:

#+begin_src fennel
(fn [...]
  (advice-function (table.unpack [...])))
#+end_src

Example:

#+begin_src fennel
(import-macros {: defn
                : defadvice} :lib.advice.macros)

(defn defn-func-6
      [x y z]
      "docstr"
      "Hi")

(defadvice defn-func-override
           [x y z]
           :override defn-func-6
           "Overrides defn-func-6"
           "over-it")

(defn-func-6)
;; => "over-it"
#+end_src

** around

Wraps the target function and receives the original function as the
first value followed by the arguments the original function was called
with. This is the best choice for customizing the modal behavior in
the spacehammer menu because it allows you to customize the arguments
provided to the lower-level alert API but does not require a full
re-implementation. This advise-type is the most versatile.

Behavior:

#+begin_src fennel
(fn [...]
  (advice-function original-function (table.unpack [...])))
#+end_src

Example:

#+begin_src fennel
(import-macros {: defn
                : defadvice} :lib.advice.macros)

(defn defn-func-7
      [x y z]
      "docstr"
      "Good job,")

(defadvice defn-func-around
           [orig-fn x y z]
           :around defn-func-7
           "Wraps defn-func-6"
           ;; May call orig-fn anytime, maybe even more than once
           ;; and return anything
           (.. "Yay! " (orig-fn x y z) " me"))

(defn-func-7)
;; => "Yay! Good job, me"
#+end_src

** before

Call a function before the original function with the same arguments.
Return value is discarded from the advising function.

** before-while

Call a function before the original function with the same arguments.
If the return value of the advising function is truthy, it will also
call the original function with the same arguments. If the return
value is falsey, the original function will not be called.

** before-until

Call a function before the original function with the same arguments.
If the return value of the advising function is falsey, it will then
call the original function with the same arguments. If the return
value is truthy, the original function will not be called. It behaves
like the inverse of =before-while=.

** after

Call a function after the original function with the same arguments.
The return value of the advised function is discarded as it is
intended for performing side-effects.

** after-while

Calls the original function first, if it returns a truthy value the
advising function is also called with the same arguments and its
return value is what the caller receives.

** after-until

Calls the original function first, if it returns a falsey value the
advising function is also called with the same arguments and its
return value is what the caller receives. It behaves like the inverse
of =after-while=.

** filter-args

The advising function is called with the args provided by the caller,
it must return a table list of args to apply to the original function.
It is used for transforming arguments, similar to around but without
having access to the original.

** filter-return

The advising function is called with the return value of the original
function. It may transform the return value and return the transformed
value to the caller. It is also similar to around but without access
to the original.

* Prior Art

This concept was directly inspired and arguably ripped-off of emacs'
advising system. Much of their docs are relevant to this, if you would
like to dig deeper check out the official [[emacs advising docs][https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html]]
